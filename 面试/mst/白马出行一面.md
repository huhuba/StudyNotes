​	业务决定技术栈：高并发+多缓存

# Spring

		## 1：Spring启动时Bean的实例化过程？

		## 2：Spring启动完成以后，需要做些东西该怎么做？

##		3：Spring循环依赖，产生的原因？能解决怎么样的循环依赖？不能解决怎么样的循环依赖？

### 1:哪些循环依赖问题Spring解决不了？

https://blog.csdn.net/wang489687009/article/details/120546430
### 2:@Lazy原理分析——它为什么可以解决特殊的循环依赖问题

https://blog.csdn.net/wang489687009/article/details/120577472

# java基础	

	## 1:HashMap,多线程死循环是最致命的问题。

	## 2:HashMap1.8采用链表和红黑树，使用红黑树不使用平衡二叉树的原因，除了平衡二叉树需要调整更多的次数，需要更多时间以外，还有其他的原因采用红黑树吗？
	
## 3:ConcurrentHashMap底层原理

	## 4:ArrayList的多线程应用有哪些？Collections.synchronizedList();

	## 5:这种结构的值，怎么缓存？

```json
key1{
	key2{
		key3{
		}
	}
}
```

##6：两个很多数据的文件，怎么比对这两个文件？
1. ​	分桶
2. ​	Hash值

7：		

# 数据库

## 1:事务的隔离级别+传播属性：

  数据库的隔离级别：一共四种

1：读未提交。会出现

1. ​	脏读：事务A读出了另外的事务B没有提交的语句的结果，之后事务B回滚以后，A读出的值就成了脏数据。
2. ​	不可重复读：同一个事务A连续两次查询，查询的结果中某一行的数据前后不一样，产生原因:A事务的两次查询中 间，其他事务B对同一行数据进行了修改并提交。
3. ​	幻读：同一个事务A连续两次查询，查询的结果中数据的数量前后不一样，产生的原因：A事务的两次查询中间，其他事务B对同一表的行数进行了修改。

2：读已提交（只读取已经提交的数据）。不会出现脏读，但是会出现不可重复读和幻读。

3：可重复读（一个事务不能读取其他事务未提交的数据(PS:锁行？)）。不会出现脏读和不可重复读，但是会出现幻读。

4：序列化，事务串型执行。不会出现脏读，不可重复读，幻读。

数据库的引擎+索引优化：		
	
nosql:

mq:  

redis: