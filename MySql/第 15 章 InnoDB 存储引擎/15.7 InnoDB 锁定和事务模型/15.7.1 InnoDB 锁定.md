### 15.7.1 InnoDB 锁定



本节介绍 `InnoDB`.

- [共享锁和排它锁](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-shared-exclusive-locks)
- [意向锁](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-intention-locks)
- [记录锁](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-record-locks)
- [间隙锁](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-gap-locks)
- [下一键锁](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-next-key-locks)
- [插入意向锁](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-insert-intention-locks)
- [AUTO-INC 锁](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-auto-inc-locks)
- [空间索引的谓词锁](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-predicate-locks)

#### 共享锁和排它锁

`InnoDB`实现标准的行级锁定，其中有两种类型的锁， [共享（`S`）锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_shared_lock)和[排他（`X`）锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_exclusive_lock)。

- [共享 ( `S`) 锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_shared_lock)允许持有该锁的事务读取一行 。
- [独占 ( `X`) 锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_exclusive_lock)允许持有该锁的事务更新或删除一行 。

如果事务在 row 上`T1`持有共享 ( `S`) 锁`r`，则来自某个不同事务`T2` 的对 row 锁的请求`r`按如下方式处理：

- 可以立即授予锁`T2`请求 。`S`结果，两者都`T1`保持`T2` 锁定`S`状态`r`。
- 不能立即授予锁 `T2`请求 。`X`

如果事务在 row 上`T1`持有独占 ( ) 锁，则无法立即授予来自某个不同事务的对任一类型锁的请求。相反，事务必须等待事务释放其对 row 的锁定。 `X``r``T2``r``T2``T1``r`

#### 意向锁

`InnoDB`支持*多粒度锁定*，允许行锁和表锁共存。例如，诸如这样的语句 在指定的表上[`LOCK TABLES ... WRITE`](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html)获取了一个排他锁（一个锁）。`X`为了使多粒度级别的锁定变得实用，`InnoDB`请使用 [意图锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_lock)。意向锁是表级锁，它指示事务稍后对表中的行需要哪种类型的锁（共享或独占）。有两种类型的意图锁：

- [意向共享锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_shared_lock)( `IS`) 表示事务打算在表中的各个行上设置 共享 锁 *。*
- [意向排他锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_exclusive_lock) ( )`IX`表示事务打算对表中的各个行设置排他锁。

例如，[`SELECT ... FOR SHARE`](https://dev.mysql.com/doc/refman/8.0/en/select.html)设置一个`IS`锁，并 [`SELECT ... FOR UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/select.html)设置一个`IX`锁。

意图锁定协议如下：

- 在事务可以获取表中行的共享锁之前，它必须首先获取`IS`表上的锁或更强的锁。
- 在事务可以获取表中行的排他锁之前，它必须首先获取`IX` 表上的锁。

下面的矩阵总结了表级锁类型的兼容性。

|      | `X`  | `IX`   | `S`    | `IS`   |
| :--- | :--- | :----- | :----- | :----- |
| `X`  | 冲突 | 冲突   | 冲突   | 冲突   |
| `IX` | 冲突 | 兼容的 | 冲突   | 兼容的 |
| `S`  | 冲突 | 冲突   | 兼容的 | 兼容的 |
| `IS` | 冲突 | 兼容的 | 兼容的 | 兼容的 |

如果锁与现有锁兼容，则将锁授予请求事务，但如果与现有锁冲突则不会。事务等待直到释放冲突的现有锁。[如果锁请求与现有锁冲突并且由于会导致死锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_deadlock)而无法授予 ，则会发生错误。

[`LOCK TABLES ... WRITE`](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html)除了全表请求（例如， ） 之外，意图锁不会阻塞任何东西。意图锁的主要目的是表明有人正在锁定一行，或者要锁定表中的一行。

[意向锁的事务数据在InnoDB 监视器](https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html) 输出 [`SHOW ENGINE INNODB STATUS`](https://dev.mysql.com/doc/refman/8.0/en/show-engine.html)中 类似于以下内容：

```sql
TABLE LOCK table `test`.`t` trx id 10080 lock mode IX
```

#### 记录锁

记录锁是对索引记录的锁。例如， `SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;` 阻止任何其他事务插入、更新或删除值为 的`t.c1`行 `10`。

记录锁总是锁定索引记录，即使定义的表没有索引。对于这种情况， `InnoDB`创建一个隐藏的聚集索引并将该索引用于记录锁定。请参阅 [第 15.6.2.1 节，“聚集索引和二级索引”](https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html)。

[记录锁的事务数据在InnoDB 监视器](https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html) 输出 [`SHOW ENGINE INNODB STATUS`](https://dev.mysql.com/doc/refman/8.0/en/show-engine.html)中 显示类似于以下内容：

```sql
RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`
trx id 10078 lock_mode X locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000274f; asc     'O;;
 2: len 7; hex b60000019d0110; asc        ;;
```

#### 间隙锁

间隙锁是在索引记录之间的间隙上的锁，或在第一条索引记录之前或最后一条索引记录之后的间隙上的锁。例如，`SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;`阻止其他事务将值`15`插入 column `t.c1`，无论该列中是否已经存在任何此类值，因为该范围内所有现有值之间的间隙都已锁定。

间隙可能跨越单个索引值、多个索引值，甚至是空的。

间隙锁是性能和并发性之间权衡的一部分，并且用于某些事务隔离级别而不是其他级别。

使用唯一索引锁定行以搜索唯一行的语句不需要间隙锁定。（这不包括搜索条件仅包括多列唯一索引的某些列的情况；在这种情况下，确实会发生间隙锁定。）例如，如果该`id`列具有唯一索引，则以下语句仅使用值为 100的行的索引记录锁，`id`其他会话是否在前面的间隙中插入行无关紧要：

```sql
SELECT * FROM child WHERE id = 100;
```

如果`id`没有索引或具有非唯一索引，则该语句会锁定前面的间隙。

这里还值得注意的是，不同的事务可以在间隙上持有冲突的锁。例如，事务 A 可以在一个间隙上持有一个共享间隙锁（gap S-lock），而事务 B 在同一个间隙上持有一个排他性间隙锁（gap X-lock）。允许冲突间隙锁的原因是，如果从索引中清除记录，则必须合并不同事务在记录上持有的间隙锁。

间隙锁定`InnoDB`是“纯粹的抑制性”，这意味着它们的唯一目的是防止其他事务插入到间隙中。间隙锁可以共存。一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。共享和独占间隙锁之间没有区别。它们彼此不冲突，并且执行相同的功能。

可以显式禁用间隙锁定。如果您将事务隔离级别更改为 ，则会发生这种情况 [`READ COMMITTED`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed)。在这种情况下，间隙锁定对搜索和索引扫描禁用，仅用于外键约束检查和重复键检查。

[`READ COMMITTED`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed)使用隔离级别 还有其他效果 。`WHERE`在 MySQL 评估条件后释放不匹配行的记录锁。对于 `UPDATE`语句，`InnoDB` 执行“半一致”读取，以便将最新提交的版本返回给 MySQL，以便 MySQL 可以确定该行是否匹配 `WHERE` .[`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)

#### 下一键锁

下一个键锁是索引记录上的记录锁和索引记录之前的间隙上的间隙锁的组合。

`InnoDB`执行行级锁定的方式是，当它搜索或扫描表索引时，它会在它遇到的索引记录上设置共享或排他锁。因此，行级锁实际上是索引记录锁。索引记录上的 next-key 锁定也会影响该索引记录之前的“ gap ”。也就是说，next-key 锁是索引记录锁加上索引记录前面的间隙上的间隙锁。如果一个会话在索引中的记录上具有共享或排他锁 `R`，则另一个会话不能 `R`在索引顺序中紧接之前的间隙中插入新的索引记录。

假设索引包含值 10、11、13 和 20。该索引可能的下一个键锁定涵盖以下区间，其中圆括号表示排除区间端点，方括号表示包含端点：

```none
(negative infinity, 10]
(10, 11]
(11, 13]
(13, 20]
(20, positive infinity)
```

对于最后一个间隔，next-key lock 锁定索引中最大值上方的间隙，并且“ supremum ” 伪记录的值高于索引中的任何实际值。上界不是真正的索引记录，因此，实际上，这个下一个键锁只锁定最大索引值之后的间隙。

默认情况下，`InnoDB`在 [`REPEATABLE READ`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read)事务隔离级别下运行。在这种情况下，`InnoDB`使用 next-key 锁进行搜索和索引扫描，这可以防止幻行（请参阅[第 15.7.4 节，“幻行”](https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html)）。

[下一键锁的事务数据在InnoDB 监视器](https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html) 输出 [`SHOW ENGINE INNODB STATUS`](https://dev.mysql.com/doc/refman/8.0/en/show-engine.html)中 显示类似于以下内容：

```sql
RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`
trx id 10080 lock_mode X
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000274f; asc     'O;;
 2: len 7; hex b60000019d0110; asc        ;;
```

#### 插入意向锁

插入意向锁是一种 [`INSERT`](https://dev.mysql.com/doc/refman/8.0/en/insert.html)在行插入之前由操作设置的间隙锁。此锁表示插入的意图，即如果插入到同一索引间隙中的多个事务未插入到间隙内的同一位置，则它们无需相互等待。假设有值为 4 和 7 的索引记录。分别尝试插入值 5 和 6 的单独事务，在获得插入行的排他锁之前，每个使用插入意向锁锁定 4 和 7 之间的间隙，但不要相互阻塞，因为行是不冲突的。

以下示例演示了在获得插入记录的排他锁之前获取插入意图锁的事务。该示例涉及两个客户端，A 和 B。

客户端 A 创建一个包含两条索引记录（90 和 102）的表，然后启动一个事务，该事务将排他锁放在 ID 大于 100 的索引记录上。排他锁包括记录 102 之前的间隙锁：

```sql
mysql> CREATE TABLE child (id int(11) NOT NULL, PRIMARY KEY(id)) ENGINE=InnoDB;
mysql> INSERT INTO child (id) values (90),(102);

mysql> START TRANSACTION;
mysql> SELECT * FROM child WHERE id > 100 FOR UPDATE;
+-----+
| id  |
+-----+
| 102 |
+-----+
```

客户端 B 开始事务以将记录插入到间隙中。事务在等待获得排他锁时采用插入意向锁。

```sql
mysql> START TRANSACTION;
mysql> INSERT INTO child (id) VALUES (101);
```

[插入意图锁的事务数据在InnoDB 监视器](https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html) 输出 [`SHOW ENGINE INNODB STATUS`](https://dev.mysql.com/doc/refman/8.0/en/show-engine.html)中 显示类似于以下内容 ：

```sql
RECORD LOCKS space id 31 page no 3 n bits 72 index `PRIMARY` of table `test`.`child`
trx id 8731 lock_mode X locks gap before rec insert intention waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000066; asc    f;;
 1: len 6; hex 000000002215; asc     " ;;
 2: len 7; hex 9000000172011c; asc     r  ;;...
```

#### AUTO-INC 锁

锁是一种`AUTO-INC`特殊的表级锁，由插入到具有 `AUTO_INCREMENT`列的表中的事务使用。在最简单的情况下，如果一个事务正在向表中插入值，则任何其他事务都必须等待自己向该表中插入，以便第一个事务插入的行接收连续的主键值。

该[`innodb_autoinc_lock_mode`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode) 变量控制用于自动增量锁定的算法。它允许您选择如何在可预测的自动递增值序列和插入操作的最大并发性之间进行权衡。

有关更多信息，请参阅 [第 15.6.1.6 节，“InnoDB 中的 AUTO_INCREMENT 处理”](https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html)。

#### 空间索引的谓词锁



`InnoDB`支持`SPATIAL` 对包含空间数据的列进行索引（请参阅 [第 11.4.9 节，“优化空间分析”](https://dev.mysql.com/doc/refman/8.0/en/optimizing-spatial-analysis.html)）。

为了处理涉及 `SPATIAL`索引的操作的锁定，next-key 锁定不能很好地支持[`REPEATABLE READ`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read)或 [`SERIALIZABLE`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_serializable)事务隔离级别。多维数据中没有绝对排序的概念，所以不清楚哪个是 “下一个”关键。

`SPATIAL`要启用对具有索引 的表的隔离级别的支持 ，请`InnoDB` 使用谓词锁。索引包含`SPATIAL`最小边界矩形 (MBR) 值，因此 `InnoDB`通过对用于查询的 MBR 值设置谓词锁定来强制对索引进行一致读取。其他事务无法插入或修改与查询条件匹配的行。