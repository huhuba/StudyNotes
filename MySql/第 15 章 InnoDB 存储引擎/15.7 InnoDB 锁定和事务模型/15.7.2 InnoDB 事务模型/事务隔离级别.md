#### 15.7.2.1 事务隔离级别



事务隔离是数据库处理的基础之一。Isolation 是首字母缩写词 [ACID](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_acid)中的 I ；隔离级别是在多个事务同时进行更改和执行查询时微调性能与结果的可靠性、一致性和可再现性之间的平衡的设置。

`InnoDB`提供 SQL:1992 标准描述的所有四个事务隔离级别 ： [`READ UNCOMMITTED`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-uncommitted)、、、 和 。的默认隔离级别是 . [`READ COMMITTED`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed)[`REPEATABLE READ`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read)[`SERIALIZABLE`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_serializable)`InnoDB`[`REPEATABLE READ`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read)

[`SET TRANSACTION`](https://dev.mysql.com/doc/refman/8.0/en/set-transaction.html)用户可以使用该语句 更改单个会话或所有后续连接的隔离级别。要为所有连接设置服务器的默认隔离级别，请 [`--transaction-isolation`](https://dev.mysql.com/doc/refman/8.0/en/server-options.html#option_mysqld_transaction-isolation)在命令行或选项文件中使用该选项。有关隔离级别和级别设置语法的详细信息，请参阅 [第 13.3.7 节，“SET TRANSACTION 语句”](https://dev.mysql.com/doc/refman/8.0/en/set-transaction.html)。

`InnoDB`[使用不同的锁定](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_locking)策略支持此处描述的每个事务隔离级别 。[对于ACID](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_acid)合规性很重要[`REPEATABLE READ`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read)的关键数据操作， 您可以强制执行与默认级别的高度一致性 。或者，您可以使用甚至 放宽一致性规则， 例如在批量报告等情况下，精确的一致性和可重复的结果比最小化锁定开销更重要。 执行比 更严格的规则，主要用于特殊情况，例如[XA](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_xa)[`READ COMMITTED`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed)[`READ UNCOMMITTED`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-uncommitted)[`SERIALIZABLE`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_serializable)[`REPEATABLE READ`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read)事务以及解决并发和 [死锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_deadlock)问题。

下面的列表描述了 MySQL 如何支持不同的事务级别。该列表从最常用的级别到最少使用的级别。

- `REPEATABLE READ`

  

  

  这是 `InnoDB`. 同一事务中的 [一致性读取读取第一次读取建立的](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_consistent_read)[快照](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_snapshot)。这意味着，如果您[`SELECT`](https://dev.mysql.com/doc/refman/8.0/en/select.html) 在同一个事务中发出多个普通（非锁定）语句，这些 [`SELECT`](https://dev.mysql.com/doc/refman/8.0/en/select.html)语句彼此之间也是一致的。请参阅 [第 15.7.2.3 节，“一致的非锁定读取”](https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html)。

  对于[锁定读取](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_locking_read) （[`SELECT`](https://dev.mysql.com/doc/refman/8.0/en/select.html)with`FOR UPDATE`或`FOR SHARE`）、 [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)和 [`DELETE`](https://dev.mysql.com/doc/refman/8.0/en/delete.html)语句，锁定取决于语句是使用具有唯一搜索条件的唯一索引还是范围类型的搜索条件。

  - 对于具有唯一搜索条件的唯一索引， `InnoDB`只锁定找到的索引记录，而不锁定 它之前 的[间隙。](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_gap)
  - 对于其他搜索条件，`InnoDB` 锁定扫描的索引范围，使用 [间隙锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_gap_lock)或 [下一个键锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_next_key_lock) 来阻止其他会话插入该范围所覆盖的间隙。有关间隙锁和下一个键锁的信息，请参阅 [第 15.7.1 节，“InnoDB 锁定”](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)。

- `READ COMMITTED`

  

  

  每次一致读取，即使在同一个事务中，也会设置并读取自己的新快照。有关一致读取的信息，请参阅 [第 15.7.2.3 节，“一致的非锁定读取”](https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html)。

  对于锁定读取（[`SELECT`](https://dev.mysql.com/doc/refman/8.0/en/select.html) with `FOR UPDATE`or `FOR SHARE`）、[`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html) 语句和[`DELETE`](https://dev.mysql.com/doc/refman/8.0/en/delete.html) 语句，`InnoDB`只锁定索引记录，而不是它们之前的间隙，因此允许在锁定记录旁边自由插入新记录。间隙锁定仅用于外键约束检查和重复键检查。

  由于间隙锁定已禁用，因此可能会出现幻像行问题，因为其他会话可以将新行插入间隙中。有关幻影行的信息，请参阅 [第 15.7.4 节，“幻影行”](https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html)。

  `READ COMMITTED`隔离级别 仅支持基于行的二进制日志记录 。如果使用`READ COMMITTED`with [`binlog_format=MIXED`](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_format)，服务器会自动使用基于行的日志记录。

  使用`READ COMMITTED`有额外的效果：

  - For [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)or [`DELETE`](https://dev.mysql.com/doc/refman/8.0/en/delete.html)语句， `InnoDB`仅对它更新或删除的行持有锁。`WHERE`在 MySQL 评估条件后释放不匹配行的记录锁 。这大大降低了死锁的可能性，但它们仍然可能发生。
  - 对于[`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)语句，如果一行已经被锁定，则`InnoDB` 执行“半一致性”读取，将最新提交的版本返回给 MySQL，以便 MySQL 可以确定该行是否 匹配`WHERE`. [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)如果行匹配（必须更新），MySQL 再次读取该行，这一次`InnoDB`要么锁定它，要么等待锁定它。

  考虑以下示例，从该表开始：

  ```sql
  CREATE TABLE t (a INT NOT NULL, b INT) ENGINE = InnoDB;
  INSERT INTO t VALUES (1,2),(2,3),(3,2),(4,3),(5,2);
  COMMIT;
  ```

  在这种情况下，表没有索引，因此搜索和索引扫描使用隐藏的聚集索引来锁定记录（请参阅[第 15.6.2.1 节，“聚集索引和二级索引”](https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html)）而不是索引列。

  假设一个会话 [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)使用这些语句执行：

  ```sql
  # Session A
  START TRANSACTION;
  UPDATE t SET b = 5 WHERE b = 3;
  ```

  还假设第二个会话 [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)通过在第一个会话之后执行这些语句来执行：

  ```sql
  # Session B
  UPDATE t SET b = 4 WHERE b = 2;
  ```

  在[`InnoDB`](https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html)执行 each [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)时，它首先为每一行获取一个排他锁，然后决定是否修改它。如果[`InnoDB`](https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html)不修改行，则释放锁。否则， [`InnoDB`](https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html)保留锁直到事务结束。这会影响事务处理，如下所示。

  当使用默认`REPEATABLE READ` 隔离级别时，第 [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)一个在它读取的每一行上获取一个 x 锁并且不释放它们中的任何一个：

  ```none
  x-lock(1,2); retain x-lock
  x-lock(2,3); update(2,3) to (2,5); retain x-lock
  x-lock(3,2); retain x-lock
  x-lock(4,3); update(4,3) to (4,5); retain x-lock
  x-lock(5,2); retain x-lock
  ```

  第二[`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)个在尝试获取任何锁时立即阻塞（因为第一次更新在所有行上都保留了锁），并且在第一次[`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)提交或回滚之前不会继续：

  ```none
  x-lock(1,2); block and wait for first UPDATE to commit or roll back
  ```

  如果`READ COMMITTED`改为使用，则第[`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)一个在它读取的每一行上获取一个 x 锁，并为它不修改的行释放这些锁：

  ```none
  x-lock(1,2); unlock(1,2)
  x-lock(2,3); update(2,3) to (2,5); retain x-lock
  x-lock(3,2); unlock(3,2)
  x-lock(4,3); update(4,3) to (4,5); retain x-lock
  x-lock(5,2); unlock(5,2)
  ```

  对于第二个`UPDATE`， `InnoDB`进行 “半一致”读取，将读取到的每一行的最新提交版本返回给 MySQL，以便 MySQL 可以确定该行是否符合 `WHERE`条件 [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)：

  ```none
  x-lock(1,2); update(1,2) to (1,4); retain x-lock
  x-lock(2,3); unlock(2,3)
  x-lock(3,2); update(3,2) to (3,4); retain x-lock
  x-lock(4,3); unlock(4,3)
  x-lock(5,2); update(5,2) to (5,4); retain x-lock
  ```

  但是，如果`WHERE`条件包含索引列并`InnoDB`使用索引，则在获取和保留记录锁时仅考虑索引列。在下面的示例中，第 [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)一个在 b = 2 的每一行上获取并保留一个 x 锁。第二 [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)个在尝试获取相同记录上的 x 锁时阻塞，因为它还使用在列 b 上定义的索引。

  ```sql
  CREATE TABLE t (a INT NOT NULL, b INT, c INT, INDEX (b)) ENGINE = InnoDB;
  INSERT INTO t VALUES (1,2,3),(2,2,4);
  COMMIT;
  
  # Session A
  START TRANSACTION;
  UPDATE t SET b = 3 WHERE b = 2 AND c = 3;
  
  # Session B
  UPDATE t SET b = 4 WHERE b = 2 AND c = 4;
  ```

  `READ COMMITTED`隔离级别可以在启动时设置或在运行时更改 。在运行时，它可以为所有会话全局设置，也可以为每个会话单独设置。

- `READ UNCOMMITTED`

  

  

  [`SELECT`](https://dev.mysql.com/doc/refman/8.0/en/select.html)语句以非锁定方式执行，但可能会使用行的早期版本。因此，使用这个隔离级别，这样的读取是不一致的。这也称为 [脏读](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_dirty_read)。否则，此隔离级别的工作方式类似于 [`READ COMMITTED`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed).

- `SERIALIZABLE`

  

  

  此级别类似于[`REPEATABLE READ`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read)，但将所有普通 语句`InnoDB`隐式转换为if 已禁用。如果 启用， 则它是它自己的事务。因此，它是只读的，并且如果作为一致（非锁定）读取执行并且不需要阻塞其他事务，则可以序列化。（如果其他事务修改了选定的行，要强制普通 阻塞，禁用 。） [`SELECT`](https://dev.mysql.com/doc/refman/8.0/en/select.html)[`SELECT ... FOR SHARE`](https://dev.mysql.com/doc/refman/8.0/en/select.html)[`autocommit`](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_autocommit)[`autocommit`](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_autocommit)[`SELECT`](https://dev.mysql.com/doc/refman/8.0/en/select.html)[`SELECT`](https://dev.mysql.com/doc/refman/8.0/en/select.html)[`autocommit`](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_autocommit)

  笔记

  从 MySQL 8.0.22 开始，从 MySQL 授权表（通过连接列表或子查询）读取数据但不修改它们的 DML 操作不会在 MySQL 授权表上获取读取锁，无论隔离级别如何。有关详细信息，请参阅 [授予表并发性](https://dev.mysql.com/doc/refman/8.0/en/grant-tables.html#grant-tables-concurrency)。