### 15.7.3 InnoDB中不同SQL语句设置的锁



在SQL 语句处理过程中扫描的每条索引记录上都锁定了一个 lock [read](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_locking_read)、 an [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)或一个 一般设置的记录。语句中是否存在排除该行[`DELETE`](https://dev.mysql.com/doc/refman/8.0/en/delete.html)的条件并不重要 。不记得确切的条件，但只知道扫描了哪些索引范围。锁通常是 [next-key锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_next_key_lock)，它也阻止插入记录之前的“间隙” 。但是， 可以显式禁用[间隙锁定，这会导致不使用下一个键锁定。](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_gap_lock)有关详细信息，请参阅 `WHERE``InnoDB``WHERE`[第 15.7.1 节，“InnoDB 锁定”](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)。事务隔离级别也会影响设置哪些锁；请参阅 [第 15.7.2.1 节，“事务隔离级别”](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html)。

如果在搜索中使用二级索引并且要设置的索引记录锁是独占的，则`InnoDB`还检索相应的聚集索引记录并对其设置锁。

如果您没有适合您的语句的索引并且 MySQL 必须扫描整个表以处理该语句，则表的每一行都会被锁定，这反过来又会阻止其他用户对表的所有插入。创建良好的索引很重要，这样您的查询就不会扫描超出必要的行数。

`InnoDB`设置特定类型的锁如下。

- [`SELECT ... FROM`](https://dev.mysql.com/doc/refman/8.0/en/select.html)是一致读取，读取数据库的快照并且不设置锁，除非事务隔离级别设置为 [`SERIALIZABLE`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_serializable). 对于 [`SERIALIZABLE`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_serializable)级别，搜索在它遇到的索引记录上设置共享的下一个键锁。但是，对于使用唯一索引锁定行以搜索唯一行的语句，只需要一个索引记录锁。

- [`SELECT ... FOR UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/select.html)和 [`SELECT ... FOR SHARE`](https://dev.mysql.com/doc/refman/8.0/en/select.html)使用唯一索引的语句为扫描的行获取锁，并为不符合包含在结果集中的行释放锁（例如，如果它们不符合 `WHERE`子句中给定的条件）。但是，在某些情况下，可能不会立即解锁行，因为结果行与其原始源之间的关系在查询执行期间丢失。例如，在一个 [`UNION`](https://dev.mysql.com/doc/refman/8.0/en/union.html)，在评估它们是否符合结果集的条件之前，可能会将表中的已扫描（和锁定）行插入到临时表中。在这种情况下，临时表中的行与原始表中的行之间的关系丢失，并且后面的行直到查询执行结束才解锁。

- 对于[锁定读取](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_locking_read) （[`SELECT`](https://dev.mysql.com/doc/refman/8.0/en/select.html)with`FOR UPDATE`或`FOR SHARE`）、 [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)和 [`DELETE`](https://dev.mysql.com/doc/refman/8.0/en/delete.html)语句，所采用的锁取决于语句是使用具有唯一搜索条件的唯一索引还是范围类型的搜索条件。

  - 对于具有唯一搜索条件的唯一索引， `InnoDB`只锁定找到的索引记录，而不锁定它之前 的[间隙。](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_gap)
  - 对于其他搜索条件和非唯一索引， `InnoDB`锁定扫描的索引范围，使用[间隙锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_gap_lock)或 [下一个键锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_next_key_lock) 来阻止其他会话插入该范围所覆盖的间隙。有关间隙锁和下一个键锁的信息，请参阅[第 15.7.1 节，“InnoDB 锁定”](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)。

- 对于搜索遇到的索引记录， [`SELECT ... FOR UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/select.html)阻止其他会话执行 [`SELECT ... FOR SHARE`](https://dev.mysql.com/doc/refman/8.0/en/select.html)或读取某些事务隔离级别。一致读取忽略读取视图中存在的记录上设置的任何锁定。

- [`UPDATE ... WHERE ...`](https://dev.mysql.com/doc/refman/8.0/en/update.html)在搜索遇到的每条记录上设置一个排他的 next-key 锁。但是，对于使用唯一索引锁定行以搜索唯一行的语句，只需要一个索引记录锁。

- 修改聚集索引记录时[`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)，会对受影响的二级索引记录进行隐式锁定。[`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html)在插入新的二级索引记录之前执行重复检查扫描以及插入新的二级索引记录时， 该 操作也会对受影响的二级索引记录进行共享锁。

- [`DELETE FROM ... WHERE ...`](https://dev.mysql.com/doc/refman/8.0/en/delete.html)在搜索遇到的每条记录上设置一个排他的 next-key 锁。但是，对于使用唯一索引锁定行以搜索唯一行的语句，只需要一个索引记录锁。

- [`INSERT`](https://dev.mysql.com/doc/refman/8.0/en/insert.html)在插入的行上设置排他锁。这个锁是索引记录锁，不是next-key锁（即没有间隙锁），并且不会阻止其他会话在插入行之前插入到间隙中。

  在插入行之前，会设置一种称为插入意图间隙锁的间隙锁。此锁表示插入的意图，即如果插入到同一索引间隙中的多个事务未插入到间隙内的同一位置，则它们无需相互等待。假设有值为 4 和 7 的索引记录。尝试插入值 5 和 6 的单独事务在获得插入行的排他锁之前，每个使用插入意图锁锁定 4 和 7 之间的间隙，但不相互阻塞，因为行是不冲突的。

  如果发生重复键错误，则会在重复索引记录上设置共享锁。如果另一个会话已经拥有排他锁，那么如果有多个会话尝试插入同一行，则使用共享锁可能会导致死锁。如果另一个会话删除了该行，就会发生这种情况。假设一个`InnoDB`表 `t1`具有以下结构：

  ```sql
  CREATE TABLE t1 (i INT, PRIMARY KEY (i)) ENGINE = InnoDB;
  ```

  现在假设三个会话依次执行以下操作：

  第 1 节：

  ```sql
  START TRANSACTION;
  INSERT INTO t1 VALUES(1);
  ```

  第 2 节：

  ```sql
  START TRANSACTION;
  INSERT INTO t1 VALUES(1);
  ```

  第三节：

  ```sql
  START TRANSACTION;
  INSERT INTO t1 VALUES(1);
  ```

  第 1 节：

  ```sql
  ROLLBACK;
  ```

  会话 1 的第一个操作获取行的排他锁。会话 2 和 3 的操作都导致重复键错误，并且它们都请求该行的共享锁。当会话 1 回滚时，它会释放其在行上的排他锁，并授予会话 2 和 3 的排队共享锁请求。此时，会话 2 和会话 3 死锁：由于对方持有共享锁，两者都无法获得该行的排他锁。

  如果表中已经包含键值为 1 的行，并且三个会话依次执行以下操作，则会出现类似的情况：

  第 1 节：

  ```sql
  START TRANSACTION;
  DELETE FROM t1 WHERE i = 1;
  ```

  第 2 节：

  ```sql
  START TRANSACTION;
  INSERT INTO t1 VALUES(1);
  ```

  第三节：

  ```sql
  START TRANSACTION;
  INSERT INTO t1 VALUES(1);
  ```

  第 1 节：

  ```sql
  COMMIT;
  ```

  会话 1 的第一个操作获取行的排他锁。会话 2 和 3 的操作都导致重复键错误，并且它们都请求该行的共享锁。当会话 1 提交时，它会释放其对行的独占锁，并授予会话 2 和 3 的排队共享锁请求。此时，会话 2 和会话 3 死锁：由于对方持有共享锁，两者都无法获得该行的排他锁。

- [`INSERT ... ON DUPLICATE KEY UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html)与简单 [`INSERT`](https://dev.mysql.com/doc/refman/8.0/en/insert.html)的不同之处在于，当发生重复键错误时，将在要更新的行上放置排他锁而不是共享锁。对重复的主键值采用排他索引记录锁。对重复的唯一键值采用独占的下一个键锁。

- [`REPLACE`](https://dev.mysql.com/doc/refman/8.0/en/replace.html)就像 [`INSERT`](https://dev.mysql.com/doc/refman/8.0/en/insert.html)唯一键上没有冲突一样。否则，将在要替换的行上放置一个独占的 next-key 锁。

- `INSERT INTO T SELECT ... FROM S WHERE ...` 在插入`T`. 如果事务隔离级别为[`READ COMMITTED`](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed)，`InnoDB`则将搜索`S`作为一致读取（无锁）。否则，`InnoDB`在`S`. `InnoDB`在后一种情况下必须设置锁：在使用基于语句的二进制日志进行前滚恢复期间，每个 SQL 语句都必须以与最初执行的方式完全相同的方式执行。

  [`CREATE TABLE ... SELECT ...`](https://dev.mysql.com/doc/refman/8.0/en/create-table.html)[`SELECT`](https://dev.mysql.com/doc/refman/8.0/en/select.html)使用共享的 next-key 锁或作为一致读取 执行 [`INSERT ... SELECT`](https://dev.mysql.com/doc/refman/8.0/en/insert-select.html).

  当 a`SELECT`用于构造 `REPLACE INTO t SELECT ... FROM s WHERE ...` or`UPDATE t ... WHERE col IN (SELECT ... FROM s ...)`时，`InnoDB`在 table 的行上设置共享的 next-key 锁`s`。

- `InnoDB``AUTO_INCREMENT`在初始化表上先前指定的列时，在与列关联的索引的末尾设置排他锁 `AUTO_INCREMENT`。

  With [`innodb_autoinc_lock_mode=0`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode), `InnoDB`使用一种特殊的 `AUTO-INC`表锁模式，在访问自增计数器时，获取锁并保持到当前 SQL 语句的末尾（而不是整个事务的末尾）。`AUTO-INC`持有表锁时，其他客户端无法插入表中。使用. _ _ _ [`innodb_autoinc_lock_mode=1`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode)_ 表级`AUTO-INC`锁不与 [`innodb_autoinc_lock_mode=2`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode). 有关更多信息，请参阅 [第 15.6.1.6 节，“InnoDB 中的 AUTO_INCREMENT 处理”](https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html)。

  `InnoDB`获取先前初始化的`AUTO_INCREMENT`列的值而不设置任何锁。

- 如果`FOREIGN KEY`在表上定义了约束，则任何需要检查约束条件的插入、更新或删除都会在它查看的记录上设置共享记录级锁以检查约束。 `InnoDB`在约束失败的情况下也设置这些锁。

- [`LOCK TABLES`](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html)设置表锁，但 `InnoDB`设置这些锁的是层之上的更高 MySQL 层。 `InnoDB`知道表锁 if `innodb_table_locks = 1`（默认）和 [`autocommit = 0`](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_autocommit)，并且上面的 MySQL 层`InnoDB`知道行级锁。

  否则，`InnoDB`的自动死锁检测无法检测到涉及此类表锁的死锁。此外，因为在这种情况下，较高的 MySQL 层不知道行级锁，所以有可能在另一个会话当前具有行级锁的表上获得表锁。但是，这不会危及事务完整性，如 [第 15.7.5.2 节“死锁检测”](https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlock-detection.html)中所述。

- [`LOCK TABLES`](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html)`innodb_table_locks=1`if （默认）在每个表上获取两个锁。MySQL层除了表锁之外，还获取了`InnoDB`表锁。为避免获取`InnoDB`表锁，请设置 `innodb_table_locks=0`. 如果没有 `InnoDB`获取表锁， [`LOCK TABLES`](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html)即使表的某些记录被其他事务锁定，也会完成。

  在 MySQL 8.0 中， 对使用 .[`innodb_table_locks=0`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_table_locks)显式锁定的表没有影响 [`LOCK TABLES ... WRITE`](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html)。它确实对通过 [`LOCK TABLES ... WRITE`](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html)隐式（例如，通过触发器）或通过[`LOCK TABLES ... READ`](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html).

- `InnoDB`当事务提交或中止时，事务持有的 所有锁都会被释放。因此，在mode中调用表 没有多大意义， [`LOCK TABLES`](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html)因为 获取的表锁将立即释放。 `InnoDB`[`autocommit=1`](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_autocommit)`InnoDB`

- 您不能在事务中间锁定其他表，因为[`LOCK TABLES`](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html) 执行隐式[`COMMIT`](https://dev.mysql.com/doc/refman/8.0/en/commit.html)and [`UNLOCK TABLES`](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html)。