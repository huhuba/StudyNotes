#### 15.7.5.2 死锁检测



[启用死锁检测](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_deadlock_detection)（默认）时， 自动`InnoDB`检测事务 [死锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_deadlock)并回滚一个或多个事务以打破死锁。 `InnoDB`尝试选择要回滚的小事务，其中事务的大小由插入、更新或删除的行数决定。

`InnoDB`知道表锁 if `innodb_table_locks = 1`（默认）和 [`autocommit = 0`](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_autocommit)，并且它上面的 MySQL 层知道行级锁。否则， `InnoDB`无法检测到涉及 MySQL[`LOCK TABLES`](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html) 语句设置的表锁或非存储引擎设置的锁的 死锁`InnoDB`。[`innodb_lock_wait_timeout`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_lock_wait_timeout)通过设置系统变量 的值来解决这些情况 。

如果Monitor 输出`LATEST DETECTED DEADLOCK`部分 包含一条消息，说明TOO DEEP OR LONG SEIN THE LOCK TABLE WAITS-FOR GRAPH, WE WILL BOLLOWING TRANSACTION，这表明等待列表上的事务数已达到 200 的限制. 超过 200 个事务的等待列表被视为死锁，尝试检查等待列表的事务被回滚。如果锁定线程必须查看等待列表上的事务拥有的超过 1,000,000 个锁，也可能会发生相同的错误。 `InnoDB`

有关组织数据库操作以避免死锁的技术，请参阅[第 15.7.5 节，“InnoDB 中的死锁”](https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks.html)。

##### 禁用死锁检测

在高并发系统上，当多个线程等待同一个锁时，死锁检测会导致速度变慢。[`innodb_lock_wait_timeout`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_lock_wait_timeout) 有时，禁用死锁检测并在发生死锁时依赖事务回滚设置可能更有效 。可以使用该 [`innodb_deadlock_detect`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_deadlock_detect) 变量禁用死锁检测。