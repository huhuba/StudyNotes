### 15.1.1 使用 InnoDB 表的好处

`InnoDB`表有以下好处：

- 如果服务器因为硬件或软件问题而意外退出，无论当时数据库中发生了什么，重启数据库后都不需要做任何特别的事情。`InnoDB`崩溃恢复会自动完成崩溃之前提交的更改，并撤消正在进行但未提交的更改，从而允许您重新启动并从中断处继续。请参阅 [第 15.18.2 节，“InnoDB 恢复”](https://dev.mysql.com/doc/refman/8.0/en/innodb-recovery.html)。
- `InnoDB`存储引擎维护自己的缓冲池，在访问数据时将表和索引数据缓存在主内存中 。经常使用的数据直接从内存中处理。此缓存适用于多种类型的信息并加快处理速度。在专用数据库服务器上，多达 80% 的物理内存通常分配给缓冲池。请参阅[第 15.5.1 节，“缓冲池”](https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html)。
- 如果将相关数据拆分到不同的表中，则可以设置强制引用完整性的外键。请参见 [第 13.1.20.5 节，“外键约束”](https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html)。
- 如果磁盘或内存中的数据损坏，校验和机制会在您使用虚假数据之前向您发出警报。该 [`innodb_checksum_algorithm`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_checksum_algorithm) 变量定义了使用的校验和算法 `InnoDB`。
- 当您为每个表设计具有适当主键列的数据库时，涉及这些列的操作会自动优化。[`WHERE`](https://dev.mysql.com/doc/refman/8.0/en/select.html) 在从句、[`ORDER BY`](https://dev.mysql.com/doc/refman/8.0/en/select.html)从句、 [`GROUP BY`](https://dev.mysql.com/doc/refman/8.0/en/select.html) 从句、连接操作中引用主键列的速度非常快 。请参阅 [第 15.6.2.1 节，“聚集索引和二级索引”](https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html)。
- 插入、更新和删除通过称为更改缓冲的自动机制进行优化。`InnoDB` 不仅允许对同一张表进行并发读写访问，它还缓存更改的数据以简化磁盘 I/O。请参阅 [第 15.5.2 节，“更改缓冲区”](https://dev.mysql.com/doc/refman/8.0/en/innodb-change-buffer.html)。
- 性能优势不仅限于具有长时间运行查询的大型表。当从表中反复访问相同的行时，自适应哈希索引会接管以使这些查找更快，就好像它们来自哈希表一样。请参阅[第 15.5.3 节，“自适应哈希索引”](https://dev.mysql.com/doc/refman/8.0/en/innodb-adaptive-hash.html)。
- 您可以压缩表和关联的索引。请参阅 [第 15.9 节，“InnoDB 表和页面压缩”](https://dev.mysql.com/doc/refman/8.0/en/innodb-compression.html)。
- 您可以加密您的数据。请参阅 [第 15.13 节，“InnoDB 静态数据加密”](https://dev.mysql.com/doc/refman/8.0/en/innodb-data-encryption.html)。
- 您可以创建和删除索引并执行其他 DDL 操作，而对性能和可用性的影响要小得多。请参阅 [第 15.12.1 节，“在线 DDL 操作”](https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html)。
- 截断每表文件的表空间非常快，并且可以释放磁盘空间供操作系统重用，而不仅仅是`InnoDB`. 请参阅 [第 15.6.3.2 节，“File-Per-Table 表空间”](https://dev.mysql.com/doc/refman/8.0/en/innodb-file-per-table-tablespaces.html)。
- 表格数据的存储布局对于 [`BLOB`](https://dev.mysql.com/doc/refman/8.0/en/blob.html)长文本字段和`DYNAMIC`行格式更有效。请参阅 [第 15.10 节，“InnoDB 行格式”](https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html)。
- `INFORMATION_SCHEMA`您可以通过查询表 来监控存储引擎的内部工作。请参阅 [第 15.15 节，“InnoDB INFORMATION_SCHEMA 表”](https://dev.mysql.com/doc/refman/8.0/en/innodb-information-schema.html)。
- 您可以通过查询 Performance Schema 表来监控存储引擎的性能细节。请参阅 [第 15.16 节，“InnoDB 与 MySQL 性能模式的集成”](https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-schema.html)。
- 您可以将`InnoDB`表与来自其他 MySQL 存储引擎的表混合在一起，即使在同一语句中也是如此。例如，您可以使用连接操作 在单个查询中 合并来自表`InnoDB`和 表的数据。[`MEMORY`](https://dev.mysql.com/doc/refman/8.0/en/memory-storage-engine.html)
- `InnoDB`专为处理大量数据时的 CPU 效率和最佳性能而设计。
- `InnoDB`表可以处理大量数据，即使在文件大小限制为 2GB 的操作系统上也是如此。

对于`InnoDB`可以应用于 MySQL 服务器和应用程序代码的特定调整技术，请参阅 [第 8.5 节，“针对 InnoDB 表进行优化”](https://dev.mysql.com/doc/refman/8.0/en/optimizing-innodb.html)。