# 1.缓存穿透？击穿？雪崩？一致性(双写)？

# 2.bloom(布隆过滤器)？

# 3.cukoo(布谷鸟过滤器)?



# 4.RDB

# 5.AOF



# 6.AKF

 	微服务拆分思想中的四个里的其中一个？

# 7.主备？主从？

# Redis分布式锁(http://redis.cn/topics/distlock.html)



## 1.时钟漂移

https://blog.csdn.net/Androidlushangderen/article/details/43564761

## 2.活性争议

系统的活性安全基于三个主要特性:

1. 锁的自动释放（因为key失效了）：最终锁可以再次被使用.
2. 客户端通常会将没有获取到的锁删除，或者锁被取到后，使用完后，客户端会主动（提前）释放锁，而不是等到锁失效另外的客户端才能取到锁。.
3. 当客户端重试获取锁时，需要等待一段时间，这个时间必须大于从大多数Redis实例成功获取锁使用的时间，以最大限度地避免脑裂。.

然而，**当网络出现问题时系统在`失效时间(TTL)`内就无法服务，这种情况下我们的程序就会为此付出代价。如果网络持续的有问题，可能就会出现死循环了。 这种情况发生在当客户端刚取到一个锁还没有来得及释放锁就被网络隔离（）.**

如果网络一直没有恢复，这个算法会导致系统不可用.



#### 问题：

看不懂，为啥会出现死循环。
1.如果是客户端是被隔离，
	a.客户端没有拿到大多数锁，超时以后，将已经得到的锁进行（丢弃），等待下一次重试不可以吗？
	b.客户端拿到了大多数锁，成功获取到锁。正常执行完毕后，释放所有的锁。释放不了的锁，等待锁自动超时不可以吗？
2.如果是服务端拿到锁的redis服务端被隔离，
	a.客户端没有拿到大多数锁，超时以后，将已经得到的锁进行（丢弃），等待下一次重试不可以吗？
	b.客户端拿到大多数锁以后，成功获得锁，正常执行任务。之后释放所有的锁,释放不了的锁，等待超时不可以吗？
	
**难道是服务端redis被隔离，导致总的服务端个数成了偶数，造成客户端获得锁的个数永远不能>=N/2+1,所有的客户端都不能成功的获取到大多数锁，永远不能真正的获取到锁？**

##     3.性能，崩溃恢复和Redis同步

**很多用户把Redis当做分布式锁服务器，使用获取锁和释放锁的响应时间，每秒钟可用执行多少次 acquire / release 操作作为性能指标。为了达到这一要求，增加Redis实例当然可用降低响应延迟**（没有钱买硬件的”穷人”,也可以在网络方面做优化，使用非阻塞模型，一次发送所有的命令，然后异步的读取响应结果，假设客户端和redis服务器之间的RTT都差不多。

#### 问题：

为啥增加redis实例可以提升性能？
获取锁成功不是需要获取大部分redis实例的锁吗？增加实例不是增加了需要获得的服务端锁吗？这样不是降低性能吗？

**如果是增加客户端实例，不是造成更多的服务端redis锁被竞争吗？对于同一个资源锁，加入最终有一个客户端成功获得了大多数服务端的锁，那么对于其他的客户端来说获得的无效服务端锁不是更多吗（对于服务端来说，响应的无效锁的服务端更多了）,不也是浪费性能吗？**

